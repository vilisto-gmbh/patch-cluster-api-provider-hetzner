name: Release

on:
  schedule:
    - cron:  '0 23 * * *' # Execute every day at 23:00

  workflow_dispatch:
    inputs:
      releaseTag:
        description: 'Tag of the cluster-api-provider-hetzner release you want to use'
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: vilisto-gmbh/cluster-api-provider-hetzner
  UPSTREAM_REPO: syself/cluster-api-provider-hetzner


jobs:
  version:
    name: "Version"
    runs-on: ubuntu-latest

    permissions: {}

    outputs:
      version: ${{ steps.define.outputs.RELEASE_VERSION }}
      continue: ${{ steps.verify.outputs.CONTINUE }}

    steps:
      - name: Define Release Version
        id: define
        env:
          UPSTREAM_LATEST_RELEASE_URL: https://api.github.com/repos/${{ env.UPSTREAM_REPO }}/releases/latest
        run: |
          if [[ "${{ inputs.releaseTag }}" != "" ]]; then
            echo "RELEASE_VERSION=${{ inputs.releaseTag }}" >> $GITHUB_OUTPUT
          else
            echo "RELEASE_VERSION=$(curl --silent --location ${{ github.api_url }}/repos/${{ env.UPSTREAM_REPO }}/releases/latest | jq -r '.tag_name')" >> $GITHUB_OUTPUT
          fi

      - name: Verify Release Version
        id: verify
        run: |
          if [[ "$(curl --write-out '%{http_code}' --silent --output /dev/null --location ${{ github.api_url }}/repos/${{ github.repository }}/releases/tags/${{ steps.define.outputs.RELEASE_VERSION }})" -eq 200 ]]; then
            echo "Release Version ${{ steps.define.outputs.RELEASE_VERSION }} already exists. Skipping Build job"
            echo "CONTINUE=false" >> $GITHUB_OUTPUT
          else
            echo "CONTINUE=true" >> $GITHUB_OUTPUT
          fi


  build-and-push:
    name: "Build and Push"
    needs: version
    if: needs.version.outputs.continue == 'true'
    runs-on: ubuntu-latest

    permissions:
      packages: write
      contents: write

    steps:
      - name: Checkout Self
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Login to GitHub Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout Upstream
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          repository: ${{ env.UPSTREAM_REPO }}
          ref: ${{ needs.version.outputs.version }}
          path: upstream
          fetch-tags: true

      - name: Setup Go
        uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v6.1.0
        with:
          go-version-file: 'upstream/go.mod'

      - name: Generate Build Flags
        id: build-flags
        run: |
          DOCKER_BUILD_LDFLAGS="$(cd upstream && hack/version.sh)"
          echo 'DOCKER_BUILD_LDFLAGS<<EOF' >> $GITHUB_ENV
          echo $DOCKER_BUILD_LDFLAGS >> $GITHUB_ENV
          echo 'EOF' >> $GITHUB_ENV

      - name: Apply Patches
        env:
          PATCH_FILE: patches/allow-vswitch-subnet.patch
        run: |
          git apply \
            --directory upstream \
            ${PATCH_FILE}

      - name: Build and Push Image
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        with:
          context: upstream
          file: ./upstream/images/caph/Dockerfile
          push: true
          platforms: linux/amd64
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.version.outputs.version }}
          build-args: |
            LDFLAGS=${{ env.DOCKER_BUILD_LDFLAGS }}

      - name: Create Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create "${{ needs.version.outputs.version }}" \
              --title="${{ needs.version.outputs.version }}" \
              --notes="docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.version.outputs.version }}"
